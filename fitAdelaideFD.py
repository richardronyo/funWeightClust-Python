import numpy as np
import pandas as pd
from skfda.representation.basis import BSplineBasis
from skfda.representation.grid import FDataGrid
from matplotlib import pyplot as plt
import skewfunHDDC as tfun
from sklearn import metrics as met
import time

def plotAdelaideFD(fd):
    """This function plots the functional data fd. Replica of R code """
    cls = fd['groupd']  # Replace with your actual group labels

    fd['fdfull'].plot(group=cls)
    plt.show()


def fitAdelaide():
    """This function uses the coefficient matrices generated by the R code found in the de_x.csv and de_y.csv files to produce functional data objects that can be used by our model.
    Parameters
    ----------
    None

    Returns
    -------
    dict
        A dictionary containing:
        - 'fdx': Functional data object for the X basis.
        - 'fdy': Functional data object for the Y basis.
        - 'fdfull': Functional data object for the full basis.
        - 'groupd': Array indicating the group membership (Sunday or Tuesday).
        - 'labels': Array of labels (0 or 1) for each group.
    """
    x = pd.read_csv("data/de_x.csv")
    y = pd.read_csv("data/de_y.csv")

    full = pd.concat([x, y], axis=0)

    ncurves = x.shape[0]
    nsplines = y.shape[1]

    print("Number of Curves: ", ncurves)


    bbasis_x = BSplineBasis(n_basis=nsplines, domain_range=(1, 12))
    bbasis_y = BSplineBasis(n_basis=nsplines, domain_range=(13, 24))
    bbasis_fullx = BSplineBasis(n_basis=nsplines, domain_range=(1, 24))


    argvals_x = np.linspace(1, 12)
    argvals_y = np.linspace(13, 24)
    argvals_full = np.linspace(1, 24)


    evalx = bbasis_x(argvals_x)[:,:,0]
    evaly = bbasis_y(argvals_y)[:,:,0]
    evalfull = bbasis_fullx(argvals_full)[:,:,0]


    final_x = x @ evalx
    final_y = y @ evaly
    final_full = full @ evalfull


    fdx = FDataGrid(final_x, argvals_x)
    fdy = FDataGrid(final_y, argvals_y)
    fdfull = FDataGrid(final_full, argvals_full)


    return{ 'fdx': fdx.to_basis(bbasis_x),
            'fdy': fdy.to_basis(bbasis_y),
            'fdfull': fdfull.to_basis(bbasis_fullx),
            'groupd': np.repeat(["Sunday", "Tuesday"], [ncurves, ncurves]),
            'labels': np.repeat([0,1], [int(ncurves/2), int(ncurves/2)])
    }

if __name__ == "__main__":
    ans = fitAdelaide()
    models =["AKJBKQKDK","AKJBQKDK", "AKBKQKDK", "ABKQKDK", "AKBQKDK", "ABQKDK"]
    modelsys = ["EII", "VII", "EEI", "VEI"]
    labels = ans["labels"]
    res = tfun.tfunHDDC(ans['fdx'], ans['fdy'], K=2, model=models, modely=modelsys, init="kmeans", nb_rep=1, threshold=0.1)
    print(met.confusion_matrix(res.cl, labels))          

    start_time = time.time()
    res = tfun.tfunHDDC(ans['fdx'], ans['fdy'], K=2, model=models, modely=modelsys, init="kmeans", nb_rep=1, threshold=0.1, mc_cores=8)
    end_time = time.time()

    print("Time elapsed using 8 cores: ", end_time - start_time, " seconds.")